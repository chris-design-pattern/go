Builder
---
## Intent

**Builder** 복잡한 개체를 단계별로 구성 할 수있는 창의적인 디자인 패턴입니다. 패턴을 사용하면 동일한 구성 코드를 사용하여 객체의 다른 유형과 표현을 생성 할 수 있습니다.<br /><br />
![](https://images.velog.io/images/chrishan/post/d9052f52-ee81-4a7f-b135-f3caf4c02766/builder-en-2x.png)

## Structure
![](https://images.velog.io/images/chrishan/post/fc13077e-5333-4650-b01a-11b5845cf444/Screen%20Shot%202021-05-09%20at%2011.44.07.png)

## How to Implement
1. 사용 가능한 모든 제품 표현을 구축하기위한 공통 구성 단계를 명확하게 정의 할 수 있는지 확인하십시오. 그렇지 않으면 패턴 구현을 진행할 수 없습니다.<br /><br />
2. 기본 빌더 인터페이스에서 이러한 단계를 선언하십시오.<br /><br />
3. 각 제품 표현에 대한 구체적인 빌더 클래스를 만들고 해당 구성 단계를 구현합니다.<br />
   구성 결과를 가져 오는 방법을 구현하는 것을 잊지 마십시오. 빌더 인터페이스 내에서이 메소드를 선언 할 수없는 이유는 여러 빌더가 공통 인터페이스가없는 제품을 구성 할 수 있기 때문입니다. 따라서 이러한 메서드의 반환 유형이 무엇인지 알 수 없습니다. 그러나 단일 계층의 제품을 처리하는 경우 가져 오기 방법을 기본 인터페이스에 안전하게 추가 할 수 있습니다.<br /><br />
4. 디렉터 클래스를 만드는 것에 대해 생각해보십시오. 동일한 빌더 개체를 사용하여 제품을 구성하는 다양한 방법을 캡슐화 할 수 있습니다.<br /><br />
5. 클라이언트 코드는 빌더와 디렉터 개체를 모두 만듭니다. 건설이 시작되기 전에 클라이언트는 빌더 개체를 감독에게 전달해야합니다. 일반적으로 클라이언트는 감독 생성자의 매개 변수를 통해이 작업을 한 번만 수행합니다. 감독은 모든 추가 구성에서 빌더 개체를 사용합니다. 건축업자가 감독의 시공 방법으로 직접 전달되는 대안적인 접근 방식이 있습니다.<br /><br />
6. 모든 제품이 동일한 인터페이스를 따르는 경우에만 디렉터로부터 직접 시공 결과를 얻을 수 있습니다. 그렇지 않으면 클라이언트는 빌더에서 결과를 가져와야합니다.

## Pros and Cons
<span style="color:green;">O</span>. 객체를 단계별로 구성하거나 구성 단계를 연기하거나 단계를 반복적으로 실행할 수 있습니다.<br /><br />
<span style="color:green;">O</span>. 제품의 다양한 표현을 빌드 할 때 동일한 구성 코드를 재사용 할 수 있습니다.<br /><br />
<span style="color:green;">O</span>. 단일 책임 원칙. 제품의 비즈니스 로직에서 복잡한 구성 코드를 분리 할 수 있습니다.<br /><br />
<span style="color:red;">X</span>. 패턴이 여러 개의 새 클래스를 만들어야하므로 코드의 전체적인 복잡성이 증가합니다.

