Builder
---
## Intent

**Builder** 복잡한 개체를 단계별로 구성 할 수있는 창의적인 디자인 패턴입니다. 패턴을 사용하면 동일한 구성 코드를 사용하여 객체의 다른 유형과 표현을 생성 할 수 있습니다.<br /><br />
![](https://images.velog.io/images/chrishan/post/d9052f52-ee81-4a7f-b135-f3caf4c02766/builder-en-2x.png)

## Structure
![](https://images.velog.io/images/chrishan/post/5b35956f-e375-47ff-981c-35f89fea6a29/structure-indexed-2x.png)
1. **Builder** 인터페이스는 모든 유형의 빌더에 공통적인 Product 구성 단계를 선언합니다.<br /><br />
2. **Concrete Builder**는 생성 단계의 다양한 구현을 제공합니다. Concreate Builder는 공통 인터페이스를 따르지 않는 Product를 생산할 수 있습니다.<br /><br />
3. **Product**는 결과 객체입니다. 다른 빌더에 의해 생성된 Product는 동일한 클래스 계층 또는 인터페이스에 속할 필요가 없습니다.<br /><br />
4. **Director** 클래스는 생성 단계를 호출하는 순서를 정의하므로 Product의 특정 구성을 만들고 재사용할 수 있습니다.<br /><br /> 
5. **Client**는 빌더 개체 중 하나를 감독과 연결해야 합니다. 일반적으로 director 생성자의 매개변수를 통해 한 번만 수행됩니다. 그런 다음 director는 모든 추가 구성에 해당 빌더 개체를 사용합니다. 그러나 클라이언트가 빌더 개체를 director의 production method에 전달할 때 대체 접근 방식이 있습니다. 이 경우 director와 함께 무언가를 만들 때마다 다른 빌더를 사용할 수 있습니다.

## How to Implement
1. 사용 가능한 모든 제품 표현을 구축하기위한 공통 구성 단계를 명확하게 정의 할 수 있는지 확인하십시오. 그렇지 않으면 패턴 구현을 진행할 수 없습니다.<br /><br />
2. 기본 빌더 인터페이스에서 이러한 단계를 선언하십시오.<br /><br />
3. 각 제품 표현에 대한 구체적인 빌더 클래스를 만들고 해당 구성 단계를 구현합니다.<br />
   구성 결과를 가져 오는 방법을 구현하는 것을 잊지 마십시오. 빌더 인터페이스 내에서이 메소드를 선언 할 수없는 이유는 여러 빌더가 공통 인터페이스가없는 제품을 구성 할 수 있기 때문입니다. 따라서 이러한 메서드의 반환 유형이 무엇인지 알 수 없습니다. 그러나 단일 계층의 제품을 처리하는 경우 가져 오기 방법을 기본 인터페이스에 안전하게 추가 할 수 있습니다.<br /><br />
4. 디렉터 클래스를 만드는 것에 대해 생각해보십시오. 동일한 빌더 개체를 사용하여 제품을 구성하는 다양한 방법을 캡슐화 할 수 있습니다.<br /><br />
5. 클라이언트 코드는 빌더와 디렉터 개체를 모두 만듭니다. 건설이 시작되기 전에 클라이언트는 빌더 개체를 감독에게 전달해야합니다. 일반적으로 클라이언트는 감독 생성자의 매개 변수를 통해이 작업을 한 번만 수행합니다. 감독은 모든 추가 구성에서 빌더 개체를 사용합니다. 건축업자가 감독의 시공 방법으로 직접 전달되는 대안적인 접근 방식이 있습니다.<br /><br />
6. 모든 제품이 동일한 인터페이스를 따르는 경우에만 디렉터로부터 직접 시공 결과를 얻을 수 있습니다. 그렇지 않으면 클라이언트는 빌더에서 결과를 가져와야합니다.

## Pros and Cons
<span style="color:green;">O</span>. 객체를 단계별로 구성하거나 구성 단계를 연기하거나 단계를 반복적으로 실행할 수 있습니다.<br /><br />
<span style="color:green;">O</span>. 제품의 다양한 표현을 빌드 할 때 동일한 구성 코드를 재사용 할 수 있습니다.<br /><br />
<span style="color:green;">O</span>. 단일 책임 원칙. 제품의 비즈니스 로직에서 복잡한 구성 코드를 분리 할 수 있습니다.<br /><br />
<span style="color:red;">X</span>. 패턴이 여러 개의 새 클래스를 만들어야하므로 코드의 전체적인 복잡성이 증가합니다.

