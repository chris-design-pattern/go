Abstract Factory
---
## Intent

**Chain of Responsibility**는 일련의 핸들러를 따라 요청을 전달할 수 있는 행동 디자인 패턴이다. 요청을 받으면 각 핸들러는 요청을 처리할지 아니면 체인의 다음 핸들러로 전달할지 결정한다.

![](https://images.velog.io/images/chrishan/post/75864b18-8691-49d2-bf9d-f01bf4a1d709/chain-of-responsibility-2x.png)

## Structure

![](https://images.velog.io/images/chrishan/post/e275ceff-9b2e-4269-816b-56e2bdb37b4a/structure-indexed-2x.png)
1. **Handler**는 모든 구체적인 핸들러에 공통적인 인터페이스를 선언한다. 일반적으로 요청을 처리하는 단일 메서드만 포함하지만 때로는 체인에서 다음 핸들러를 설정하기 위한 다른 메서드가 있을 수도 있다.<br />
2. **Base Handler**는 모든 핸들러 클래스에 공통적인 상용구 코드를 넣을 수 있는 선택적 클래스다.<br />
   일반적으로 이 클래스는 다음 핸들러에 대한 참조를 저장하기 위한 필드를 정의한다. 클라이언트는 핸들러를 이전 핸들러의 생성자 또는 설정자에 전달하여 체인을 구축할 수 있다. 클래스는 기본 처리 동작을 구현할 수도 있다. 즉, 존재 여부를 확인한 후 다음 처리기로 실행을 전달할 수 있다.<br />
3. **Concrete Handler**에는 요청을 처리하기 위한 실제 코드가 포함되어 있다. 요청을 수신하면 각 핸들러는 요청을 처리할지 여부와 함께 체인을 따라 전달할지 여부를 결정해야 한다.<br />
   핸들러는 일반적으로 자체 포함되고 변경할 수 없으며 생성자를 통해 필요한 모든 데이터를 한 번만 수락한다.<br />
4. **Client**는 응용 프로그램의 논리에 따라 체인을 한 번만 구성하거나 동적으로 구성할 수 있다. 요청은 체인의 모든 핸들러로 보낼 수 있다. 첫 번째 핸들러일 필요는 없다.

## How to Implement

1. 핸들러 인터페이스를 선언하고 요청을 처리하는 메서드의 서명을 설명한다.<br /><br />
   클라이언트가 요청 데이터를 메소드에 전달하는 방법을 결정해야 한다. 가장 유연한 방법은 요청을 객체로 변환하여 처리 메소드에 인수로 전달하는 것이다.<br /><br />
2. 구체적인 핸들러에서 중복된 상용구 코드를 제거하려면 핸들러 인터페이스에서 파생된 추상 기본 핸들러 클래스를 만드는 것이 좋다.<br /><br />
   이 클래스에는 체인의 다음 핸들러에 대한 참조를 저장하기 위한 필드가 있어야 한다. 클래스를 불변으로 만드는 것을 고려해야 한다. 그러나 런타임에 체인을 수정하려는 경우 참조 필드의 값을 변경하기 위한 setter를 정의해야 한다.<br /><br />
   아무 것도 남지 않는 한 다음 객체로 요청을 전달하는 처리 방법에 대한 편리한 기본 동작을 구현할 수도 있다. 구체 처리기는 부모 메서드를 호출하여 이 동작을 사용할 수 있다.<br /><br />
3. 하나씩 구체적인 처리기 하위 클래스를 만들고 처리 방법을 구현한다. 각 처리기는 요청을 수신할 때 두 가지 결정을 내려야 한다.<br /><br />
    - 요청을 처리할지 여부.
    - 체인을 따라 요청을 전달할지 여부.<br /><br />
4. 클라이언트는 자체적으로 체인을 어셈블하거나 다른 개체에서 미리 빌드된 체인을 수신할 수 있다. 후자의 경우 구성 또는 환경 설정에 따라 체인을 빌드하기 위해 일부 팩토리 클래스를 구현해야 한다.<br /><br />
5. 클라이언트는 첫 번째 핸들러뿐만 아니라 체인의 모든 핸들러를 트리거할 수 있다. 요청은 일부 핸들러가 더 이상 전달을 거부하거나 체인 끝에 도달할 때까지 체인을 따라 전달된다.<br /><br />
6. 체인의 동적 특성으로 인해 클라이언트는 다음 시나리오를 처리할 준비가 되어 있어야 한다.<br /><br />
    - 체인은 단일 링크로 구성될 수 있다.
    - 일부 요청은 체인 끝에 도달하지 못할 수 있다.
    - 다른 것들은 처리되지 않은 채 체인의 끝에 도달할 수 있다.

## Pros and Cons

<span style="color:green;">O</span>. 요청 처리 순서를 제어할 수 있다.
<span style="color:green;">O</span>. 단일 책임 원칙. 작업을 수행하는 클래스에서 작업을 호출하는 클래스를 분리할 수 있다.
<span style="color:red;">X</span>. 개방/폐쇄 원칙. 기존 클라이언트 코드를 손상시키지 않고 앱에 새 핸들러를 도입할 수 있다.
