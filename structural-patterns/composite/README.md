Composite
---
## Intent
**Composite**는 객체를 트리 구조로 구성한 다음 개별 객체인것처럼 이러한 구조로 작업 할 수 있는 구조적 Design pattern입니다.
![](https://images.velog.io/images/chrishan/post/87a79cdb-9fe0-4db2-bf4f-678288d2d2aa/composite-2x.png)

## Structure
![](https://images.velog.io/images/chrishan/post/c7a56f60-0f6f-4326-9a9d-d5b85c396462/structure-en-indexed-2x.png)
1. **Component** Interface는 Tree의 단순 요소와 복잡한 요소 모두에 공통적인 작업을 설명합니다.<br /><br />
2. **Leaf**는 하위 요소가 없는 나무의 기본 요소입니다.<br />일반적으로 Leaf 구성 요소는 작업을 위임 할 사람이 없기 때문에 대부분의 실제 작업을 수행합니다.<br /><br />
3. Container(aka composite)는 sub-elements가 있는 element입니다. Container는 작식의 구체적인 클래스를 알지 못합니다. Component Interface를 통해서만 모든 하위 요소와 함께 작동합니다.<br /><br />요청을 받으면 Container는 작업을 하위 요소에 위임하고 중간 결과를 처리 한 다음 최종 결과를 Client에 반환합니다.<br /><br />
4. **Client**는 Component Interface를 통해 모든 요소와 함께 작동합니다. 결과적으로 Client는 Tree의 단순하거나 복잡한 요소 모두에서 동일한 방식으로 작업 할 수 있습니다.

## How to Implement
1. 앱의 핵심 모델이 트리 구조로 표현 될 수 있는지 확인하십시오. 간단한 요소와 컨테이너로 나누십시오. 컨테이너는 단순 요소와 기타 컨테이너를 모두 포함 할 수 있어야합니다.<br /><br />
2. 단순 구성 요소와 복잡한 구성 요소 모두에 적합한 메서드 목록으로 구성 요소 인터페이스를 선언합니다.<br /><br />
3. 간단한 요소를 나타내는 리프 클래스를 만듭니다. 프로그램에는 여러 리프 클래스가있을 수 있습니다.<br /><br />
4. 복잡한 요소를 나타내는 컨테이너 클래스를 만듭니다. 이 클래스에서 하위 요소에 대한 참조를 저장하기위한 배열 필드를 제공합니다. 배열은 잎과 컨테이너를 모두 저장할 수 있어야하므로 구성 요소 인터페이스 유형으로 선언해야합니다.<br /><br />컴포넌트 인터페이스의 메소드를 구현하는 동안 컨테이너는 대부분의 작업을 하위 요소에 위임해야합니다.<br /><br />
5. 마지막으로 컨테이너에서 자식 요소를 추가하고 제거하는 방법을 정의합니다.<br /><br />이러한 작업은 구성 요소 인터페이스에서 선언 할 수 있습니다. 이 메서드는 리프 클래스에서 비어 있기 때문에 인터페이스 분리 원칙을 위반합니다. 그러나 클라이언트는 트리를 구성 할 때도 모든 요소를 동일하게 처리 할 수 있습니다.

## Pros and Cons
<span style="color:#346751;">O</span> 복잡한 트리 구조로 더 편리하게 작업 할 수 있습니다. 다형성과 재귀를 유리하게 사용하십시오.<br /><br />
<span style="color:#346751;">O</span> 개방 / 폐쇄 원칙. 이제 개체 트리와 함께 작동하는 기존 코드를 손상시키지 않고 앱에 새 요소 유형을 도입 할 수 있습니다.<br /><br />
<span style="color:#C84B31;">X</span> 기능이 너무 많이 다른 클래스에 대한 공통 인터페이스를 제공하는 것은 어려울 수 있습니다. 특정 시나리오에서는 구성 요소 인터페이스를 지나치게 일반화하여 이해하기 어렵게 만들어야합니다.