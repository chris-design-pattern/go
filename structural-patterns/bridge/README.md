Bridge
---
## Intent
**Bridge**는 큰 클래스 또는 밀접하게 관련된 클래스 집합을 서로 독립적으로 개발할 수 있는 추상화 및 구현이라는 두개의 개별 계층으로 분할 할 수 있는 구조적 디자인 패턴입니다.
![](https://images.velog.io/images/chrishan/post/0b06d89b-300b-4563-b002-13a1207d7fad/bridge-2x.png)

## Structure
![](https://images.velog.io/images/chrishan/post/53e1a5b5-a4f4-4bbe-a2e8-aaa5f8bf5666/structure-en-indexed-2x.png)

1. **Abstraction**는 높은 수준의 제어 로직을 제공합니다. 실제 저수준 작업을 수행하기 위해 구현 개체에 의존합니다.<br /><br />
2. **Implementation**은 모든 구체적인 구현에 공통적인 인터페이스를 선언합니다. 추상화는 여기에 선언 된 메서드를 통해서만 구현 개체와 통신 할 수 있습니다.
   추상화는 구현과 동일한 메서드를 나열 할 수 있지만 일반적으로 추상화는 구현에 의해 선언 된 다양한 기본 작업에 의존하는 몇 가지 복잡한 동작을 선언합니다.<br /><br />
3. **Concrete Implementations**에는 플랫폼 별 코드가 포함됩니다.<br /><br />
4. **Refined Abstractions**는 다양한 제어 로직을 제공합니다. 부모와 마찬가지로 일반 구현 인터페이스를 통해 다른 구현으로 작업합니다.<br /><br />
5. 일반적으로 **Client**는 추상화 작업에만 관심이 있습니다. 그러나 추상화 개체를 구현 개체 중 하나와 연결하는 것은 클라이언트의 작업입니다.

## How to Implement
1. 클래스에서 직교 차원을 식별하십시오. 이러한 독립적 인 개념은 abstraction/platform, domain/infrastructure, front-end/back-end, or interface/implementation 일 수 있습니다.<br /><br />
2. 클라이언트에 필요한 작업을 확인하고 기본 추상화 클래스에서 정의합니다.<br /><br />
3. 모든 플랫폼에서 사용할 수 있는 작업을 결정합니다. 일반 구현 인터페이스에서 추상화에 필요한 것을 선언하십시오.<br /><br />
4. 도메인의 모든 플랫폼에 대해 구체적인 구현 클래스를 생성하되 모두 구현 인터페이스를 따르는지 확인하십시오.<br /><br />
5. 추상화 클래스 내에 구현 유형에 대한 참조 필드를 추가하십시오. 추상화는 대부분의 작업을 해당 필드에서 참조되는 구현 개체에 위임합니다.<br /><br />
6. 고수준 로직의 여러 변형이 있는 경우 기본 추상화 클래스를 확장하여 각 변형에 대해 정제된 추상화를 만듭니다.<br /><br />
7. 클라이언트 코드는 구현 객체를 추상화의 생성자에 전달하여 하나를 다른 객체와 연결해야 합니다. 그 후에 클라이언트는 구현을 잊어버리고 추상화 개체로만 작업 할 수 있습니다.
## Pros and Cons
<span style="color:#346751;">O</span> 플랫폼에 독립적 인 클래스와 앱을 만들 수 있습니다.<br /><br />
<span style="color:#346751;">O</span> 클라이언트 코드는 높은 수준의 추상화와 함께 작동합니다. 플랫폼 세부 정보에 노출되지 않습니다.<br /><br />
<span style="color:#346751;">O</span> 개방 / 폐쇄 원칙. 서로 독립적으로 새로운 추상화와 구현을 도입 할 수 있습니다.<br /><br />
<span style="color:#346751;">O</span> 단일 책임 원칙. 추상화의 고수준 논리와 구현의 플랫폼 세부 사항에 집중할 수 있습니다.<br /><br />
<span style="color:#C84B31;">X</span> 응집력이 높은 클래스에 패턴을 적용하여 코드를 더 복잡하게 만들 수 있습니다.