Decorator
---
## Intent
**Decorator**는 structural design pattern입니다. 객체에 동적 기능을 추가하기 위해 구조를 개선하는 패턴입니다. 다양한 확장을 위해 객체를 조합합니다.
![](https://images.velog.io/images/chrishan/post/89334069-9752-43af-8558-939ee858c635/decorator-2x.png)

## Structure
![](https://images.velog.io/images/chrishan/post/990a48d5-b994-4bdc-bbac-bf70b50a84ac/Screen%20Shot%202021-07-03%20at%2010.15.05.png)

## How to Implement
1. 비즈니스 도메인이 여러 선택적 레이어가 있는 기본 구성 요소로 표시 될 수 있는지 확인 하십시오.<br /><br />
2. 기본 구성 요소와 선택적 레이어 모두에 공통적인 방법을 파악합니다. 구성요소 인터페이스를 만들고 해당 메서드를 선언 하십시오.<br /><br />
3. 구체적인 구성 요소 클래스를 만들고 그 안에 기본 동작을 정의합니다.<br /><br />
4. 기본 데코레이터 클래스를 만듭니다. 래핑 된 개체에 대한 참조를 저장하기위한 필드가 있어야합니다. 필드는 데코레이터뿐만 아니라 구체적인 구성 요소에 연결할 수 있도록 구성 요소 인터페이스 유형으로 선언되어야합니다. 기본 데코레이터는 모든 작업을 래핑 된 객체에 위임해야합니다.<br /><br />
5. 모든 클래스가 컴포넌트 인터페이스를 구현하는지 확인하십시오.<br /><br />
6. 기본 데코레이터에서 확장하여 콘크리트 데코레이터를 만듭니다. 구체적인 데코레이터는 부모 메서드 (항상 래핑 된 개체에 위임)를 호출하기 전이나 후에 동작을 실행해야합니다.<br /><br />
7. 클라이언트 코드는 데코레이터를 만들고 클라이언트가 필요로 하는 방식으로 구성해야합니다.
## Pros and Cons
<span style="color:#346751;">O</span> 새 하위 클래스를 만들지 않고도 개체의 동작을 확장 할 수 있습니다.<br /><br />
<span style="color:#346751;">O</span> 런타임에 객체에서 책임을 추가하거나 제거 할 수 있습니다.<br /><br />
<span style="color:#346751;">O</span> 개체를 여러 데코레이터로 래핑하여 여러 동작을 결합 할 수 있습니다.<br /><br />
<span style="color:#346751;">O</span> 단일 책임 원칙. 가능한 많은 동작 변형을 구현하는 모 놀리 식 클래스를 여러 개의 작은 클래스로 나눌 수 있습니다.<br /><br />
<span style="color:#C84B31;">X</span> 래퍼 스택에서 특정 래퍼를 제거하는 것은 어렵습니다.<br /><br />
<span style="color:#C84B31;">X</span> 데코레이터의 동작이 데코레이터 스택의 순서에 의존하지 않는 방식으로 데코레이터를 구현하는 것은 어렵습니다.<br /><br />
<span style="color:#C84B31;">X</span> 레이어의 초기 구성 코드는 매우 추하게 보일 수 있습니다.